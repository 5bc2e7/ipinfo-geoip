# 工作流名称
name: Build Custom GeoIP and IP-List Files

# 工作流触发条件
on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * 4"
  push:
    branches:
      - master
    paths:
      - '.github/workflows/build.yml'

jobs:
  build:
    name: Build Multi-Country GeoIP DAT and TXT Files
    runs-on: ubuntu-latest
    
    # --- 核心改造 1: 定义国家列表 ---
    # 在这里定义所有需要处理的国家/地区代码，用空格隔开。
    # 未来想增加或删除国家，只需修改这一行！
    env:
      COUNTRIES: "SG HK JP"

    steps:
      # 步骤1：检出 Loyalsoldier/geoip 的代码 (无变化)
      - name: Checkout geoip tool codebase
        uses: actions/checkout@v4
        with:
          repository: Loyalsoldier/geoip
          path: ./geoip-tool

      # 步骤2：设置 Go 环境 (无变化)
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: ./geoip-tool/go.mod

      # 步骤3：设置动态变量 (无变化)
      - name: Set dynamic variables
        run: |
          echo "TAG_NAME=$(date +%Y%m%d%H%M)" >> $GITHUB_ENV
          echo "RELEASE_NAME=$(date +%Y%m%d%H%M)" >> $GITHUB_ENV
        shell: bash

      # 步骤4：下载、校验并解压 IPinfo Lite CSV (无变化)
      - name: Download, Verify and Unzip IPinfo Lite CSV
        env:
          IPINFO_TOKEN: ${{ secrets.IPINFO_TOKEN }}
        run: |
          mkdir -p ./data
          echo "Downloading ipinfo_lite.csv.gz..."
          curl -fL "https://ipinfo.io/data/ipinfo_lite.csv.gz?token=${IPINFO_TOKEN}" -o ./data/ipinfo_lite.csv.gz
          echo "Downloading checksums..."
          curl -sfL "https://ipinfo.io/data/ipinfo_lite.csv.gz/checksums?token=${IPINFO_TOKEN}" -o ./data/checksums.json
          echo "Verifying file integrity..."
          official_sha256=$(jq -r '.checksums.sha256' ./data/checksums.json)
          local_sha256=$(sha256sum ./data/ipinfo_lite.csv.gz | awk '{print $1}')
          echo "Official SHA256: ${official_sha256}"
          echo "Local SHA256:    ${local_sha256}"
          if [ "${official_sha256}" != "${local_sha256}" ]; then
            echo "FATAL: Checksum mismatch! The downloaded file may be corrupted."
            exit 1
          fi
          echo "✅ Checksum match. Unzipping the file..."
          gunzip < ./data/ipinfo_lite.csv.gz > ./data/ipinfo_lite.csv
          
      # --- 核心改造 2: 循环提取 IP ---
      # 步骤5：循环提取并分流所有指定国家的 IP 地址段
      - name: Extract and Split IP Ranges for All Countries
        id: extract_ips
        run: |
          HAS_ANY_FILES=false
          # 遍历在 env 中定义的国家列表
          for country_code in ${COUNTRIES}; do
            echo "--- Processing for country: ${country_code} ---"
            lc_country_code=$(echo "${country_code}" | tr '[:upper:]' '[:lower:]')
            
            # 使用 awk 提取当前循环国家的 IP
            # 通过 -v 选项将 shell 变量 country_code 传递给 awk
            cat ./data/ipinfo_lite.csv | \
            awk -v cc_filter="${country_code}" '
            BEGIN { FS = "," }
            NR == 1 {
                for (i=1; i<=NF; i++) {
                    header_field = $i; gsub(/"|\r/, "", header_field)
                    if (header_field == "country_code") { cc_idx = i }
                    if (header_field == "network") { network_idx = i }
                }
                if (cc_idx == 0 || network_idx == 0) { exit 1 }
                next
            }
            {
                country_code_field = $(cc_idx); gsub(/"|\r/, "", country_code_field)
                if (country_code_field == cc_filter) {
                    network = $(network_idx); gsub(/"|\r/, "", network)
                    print network
                }
            }
            ' > ./${lc_country_code}_cidrs_all.txt
            
            # 检查是否为当前国家提取到了数据
            if [ -s ./${lc_country_code}_cidrs_all.txt ]; then
              HAS_ANY_FILES=true
              grep '\.' ./${lc_country_code}_cidrs_all.txt > ./${lc_country_code}_cidrs_ipv4.txt
              grep ':' ./${lc_country_code}_cidrs_all.txt > ./${lc_country_code}_cidrs_ipv6.txt
              echo "✅ Successfully extracted $(wc -l < ./${lc_country_code}_cidrs_all.txt) ranges for ${country_code}."
            else
              echo "⚠️ Could not find any IP ranges for ${country_code}."
              # 删除空文件
              rm ./${lc_country_code}_cidrs_all.txt
            fi
          done
          
          # 根据是否生成了任何文件，设置输出变量
          if [ "${HAS_ANY_FILES}" = "true" ]; then
            echo "has_files=true" >> $GITHUB_OUTPUT
          else
            echo "has_files=false" >> $GITHUB_OUTPUT
          fi

      # --- 核心改造 3: 动态生成 DAT 配置文件 ---
      # 步骤6：动态生成 DAT 文件的配置文件并执行转换
      - name: Generate DAT files
        if: steps.extract_ips.outputs.has_files == 'true'
        working-directory: ./geoip-tool
        run: |
          go build ./
          
          # 初始化一个空的 JSON 配置文件
          CONFIG_JSON='{"input": [], "output": []}'
          
          # 再次遍历国家列表，为每个国家生成对应的 JSON 配置条目
          for country_code in ${COUNTRIES}; do
            lc_country_code=$(echo "${country_code}" | tr '[:upper:]' '[:lower:]')

            # 仅当该国家对应的 IP 文件存在时，才为其生成配置
            if [ -f "${{ github.workspace }}/${lc_country_code}_cidrs_all.txt" ]; then
              echo "--- Generating config for ${country_code} ---"
              # 使用 jq 工具动态地向 JSON 中添加 input 和 output 规则
              CONFIG_JSON=$(echo "${CONFIG_JSON}" | jq \
                --arg lc_code "${lc_country_code}" \
                --arg ws_path "${{ github.workspace }}" \
                '.input += [
                  {"type": "text", "action": "add", "args": {"name": $lc_code, "uri": "\($ws_path)/\($lc_code)_cidrs_all.txt"}},
                  {"type": "text", "action": "add", "args": {"name": "\($lc_code)_ipv4", "uri": "\($ws_path)/\($lc_code)_cidrs_ipv4.txt"}},
                  {"type": "text", "action": "add", "args": {"name": "\($lc_code)_ipv6", "uri": "\($ws_path)/\($lc_code)_cidrs_ipv6.txt"}}
                ] | .output += [
                  {"type": "v2rayGeoIPDat", "action": "output", "args": {"outputDir": "\($ws_path)/output", "outputName": "geoip-\($lc_code).dat", "wantedList": [$lc_code]}},
                  {"type": "v2rayGeoIPDat", "action": "output", "args": {"outputDir": "\($ws_path)/output", "outputName": "geoip-\($lc_code)-ipv4.dat", "wantedList": ["\($lc_code)_ipv4"]}},
                  {"type": "v2rayGeoIPDat", "action": "output", "args": {"outputDir": "\($ws_path)/output", "outputName": "geoip-\($lc_code)-ipv6.dat", "wantedList": ["\($lc_code)_ipv6"]}}
                ]')
            fi
          done
          
          # 将最终生成的完整 JSON 写入文件
          echo "${CONFIG_JSON}" | jq . > ./config.json
          echo "Generated config.json:"
          cat ./config.json
          
          mkdir -p ${{ github.workspace }}/output
          ./geoip convert -c ./config.json
          echo "✅ All DAT conversions completed successfully!"

      # 步骤7：准备 .txt 文件用于发布 (使用通配符，无需修改)
      - name: Prepare text files for publishing
        if: steps.extract_ips.outputs.has_files == 'true'
        run: |
          # 通配符 `*` 会自动匹配所有国家的文件 (sg_*, hk_*, 等)
          mv ./*_cidrs_*.txt ./output/

      # 步骤8, 9, 10, 11: 这些步骤都作用于 output 目录，它们会自动处理所有生成的文件，无需任何修改。
      - name: Generate sha256 checksums
        if: steps.extract_ips.outputs.has_files == 'true'
        run: |
          cd ./output
          for name in $(ls *.dat *.txt); do
            sha256sum ${name} > ./${name}.sha256sum
          done
          echo "Generated files and checksums:"
          ls -l

      - name: Git push assets to "release" branch
        if: steps.extract_ips.outputs.has_files == 'true'
        run: |
          cd ./output
          git init
          git config --local user.name "github-actions[bot]"
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout -b release
          git add -A
          git commit -m "Release: ${{ env.RELEASE_NAME }}"
          git remote add origin "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin release

      - name: Purge jsdelivr CDN
        if: steps.extract_ips.outputs.has_files == 'true'
        run: |
          cd ./output
          for file in $(ls); do
            echo "Purging ${file} from jsDelivr..."
            curl -sL "https://purge.jsdelivr.net/gh/${{ github.repository }}@release/${file}"
          done

      - name: Upload files to GitHub Release
        if: steps.extract_ips.outputs.has_files == 'true'
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ./output/*
          file_glob: true
          release_name: ${{ env.RELEASE_NAME }}
          tag: ${{ env.TAG_NAME }}
          overwrite: true
